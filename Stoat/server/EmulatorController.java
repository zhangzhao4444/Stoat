import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.ArrayList;
import java.util.List;


/** 
 * the controller manages multiple (emulator) agents through sockets
 * */
class EmulatorController implements Runnable{
	
	private final static String debugFlag = "[AgentController] ";
	
	private int socketServerPortNumber;
	
	/** the pool of all agents which are used to execute tests */
	private List<EmulatorAgent> agentsPool;
		
	/** the thread which the controller runs in */
	private Thread controllerThread;
	private String controllerThreadName;

	/**
	 * The event sequences (i.e., test sequences) generated by the MCMC sampler.
	 * One event sequence is composed of multiple UI actions.
	 */
	private List<ArrayList<String>> eventSequences;
	/** the number of event sequences */
	private static int eventSequencesCnt;
	
	private static String lineCoverage;
	
	public EmulatorController(String controllerName){
		
		controllerThreadName = controllerName;
		socketServerPortNumber = ConfigOptions.PORT;
		
		System.out.println(debugFlag + "I: create controller " + controllerThreadName + ", at port: " + socketServerPortNumber);
		
		//init. the emulator agents
		agentsPool = new ArrayList<EmulatorAgent>();
		eventSequences = new ArrayList<ArrayList<String>>();
	}
	

	public void run() {
		System.out.println(debugFlag + "I: run controller " + controllerThreadName);
		
		//start the socket server
		try {
			startSocketServer();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	public void start(){
		System.out.println(debugFlag + "I: start controller " + controllerThreadName);
		if(controllerThread == null){
			controllerThread = new Thread(this, controllerThreadName);
		}
		//use start() instead of run() to create a new thread, and the "run()" function will be called
		controllerThread.start();
	}
	
	/** assign a new an agent name */
	private String assignAgentName(){
		int size = agentsPool.size();
		String agentName = "testAVD_" + (size+1);
		System.out.println(debugFlag + "I: assign a new agent name: " + agentName);
		return agentName;
	}
	
	public void startSocketServer() throws IOException{
		
		System.out.println(debugFlag + "I: the server is started ... ");
    	
    	//open a server socket
        ServerSocket listener = new ServerSocket(socketServerPortNumber);
        try {
            while (true) {
            	//listen for and accept connections from clients
                Socket serverSocket = listener.accept();
                System.out.println(debugFlag + "I: a client connected to this server. ");
                try {
                	BufferedReader input =
        		            new BufferedReader(new InputStreamReader(serverSocket.getInputStream()));
                	PrintWriter output =
                            new PrintWriter(serverSocket.getOutputStream(), true);
                	
                	String line;
                	StringBuffer clientMessage = new StringBuffer("");
                	
                	while(true){
                		
                		clientMessage.setLength(0);
                	
                		while((line = input.readLine())==null);
                		System.out.println(debugFlag + "I: line = " + line);
                		
                		if(line.equals("REQ_TS")){
                			while(eventSequences.size()==0){
                				//If the test suite is not prepared, wait here!
								try {
									Thread.sleep(5000);
								} catch (InterruptedException e) {
									e.printStackTrace();
								}
                			}
                			int test_suite_size = eventSequences.size();
                			System.out.println(debugFlag + "I: total " + test_suite_size + " test sequences");
                			for(int i=0; i<test_suite_size; i++){
                				ArrayList<String> eventSequence = eventSequences.get(i);
                				String str = "";
                				for(String cmd: eventSequence){
                					str += cmd + "\n" ;
                				}
                				//Remember to add "\n" at the end of the message 
                				output.print(str);
                				output.println("END_TC");
                				//System.out.println(debugFlag + "I: the test sequence has been sent.");
                			}
                			output.println("END_TS");
                			System.out.println(debugFlag + "I: the whole test suite has been sent.");
                			//clear the event sequence
                			eventSequences.clear();
                		}else if(line.equals("PULL_COV")){
                			//get the coverage
                			line = input.readLine();
                			System.out.println(debugFlag + "I: the line coverage: " + line);
                			lineCoverage = line;
                		}else if(line.equals("STOP")){
                			// stop the mcmc sampling
                			System.out.println(debugFlag + "I: stop mcmc sampling");
                			System.exit(0); 
                		}else{
                			System.out.println(debugFlag + "E: invalid message!!!");
                			System.exit(0);
                		}
                		
                	}
                	
                }finally {
                	serverSocket.close();
                }
            }
        }finally {
            listener.close();
        }


        
	}
	
	
	public void getTestSuite(List<ArrayList<String>> testSuite) {
		eventSequences.addAll(testSuite);
		eventSequencesCnt = 0;
		System.out.println(debugFlag + "I: get the generated test suite from MCMCSampler, total " + eventSequences.size() + " tests.");
		//clear the line coverage info
		lineCoverage = "";
	}
	
	/**
	 * get the coverage information from test executions
	 * @throws InterruptedException 
	 */
	public synchronized String getTestCoverage(){
		System.out.println(debugFlag + "I: the testManager is waiting for the code coverage from controller ...");
		System.out.println(debugFlag + "I: wait for line coverage result ... ");
		while(lineCoverage.equals("")){
			//If the test suite is not prepared, wait here!
			try {
				Thread.sleep(5000);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
		return lineCoverage;
	}
	
	public synchronized void sendTestCoverage(){
		//TODO just for test, not well-implemented
		
		eventSequencesCnt += 1;
		
		System.out.println(debugFlag + "I: total test sequences cnt: " + TestManager.actualTestSuiteSize + " executed sequences cnt: " + eventSequencesCnt);
		
		if(eventSequencesCnt == TestManager.actualTestSuiteSize){
			
			System.out.println(debugFlag + "I: all test sequences in the test suite are executed, ready to get test report ...");
			
			//compute the final code coverage
			
			//get the code coverage, and give it to the MCMCSampler
			
			
			//notify the test manager to request the coverage report from the remote agent, 
			//this "notify()" corresponds to the "wait()" in the "getTestCoverage()" function.
			System.out.println(debugFlag + "I: notify the test manager to request the coverage report. ");
			notify();
		}
	}
	
}